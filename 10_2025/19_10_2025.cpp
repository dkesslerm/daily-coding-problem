#include <cstdlib>
#include <iostream>
#include <cassert>
using namespace std;

// Daily Coding Problem: Problem #24 [Medium] - 19/10/25
//
// This problem was asked by Google.
// Implement locking in a binary tree. A binary tree node can be locked
// or unlocked only if all of its descendants or ancestors are not locked.

// Design a binary tree node class with the following methods:
//     is_locked, which returns whether the node is locked
//     lock, which attempts to lock the node. If it cannot be locked, then it should return false. Otherwise, it should lock it and return true.
//     unlock, which unlocks the node. If it cannot be unlocked, then it should return false. Otherwise, it should unlock it and return true.

// You may augment the node to add parent pointers or any other property you would like.
// You may assume the class is used in a single-threaded program, so there is no need for actual locks or mutexes.
// Each method should run in O(h), where h is the height of the tree.

class LockedTreeNode {
private:
    int val;
    LockedTreeNode* left;
    LockedTreeNode* right;
    LockedTreeNode* parent;
    bool locked = false;
    int lockedDescendantCount = 0;
public:
    LockedTreeNode(int v, LockedTreeNode* p = nullptr)
        : val(v), left(nullptr), right(nullptr), parent(p) {}

    bool isLocked() {
        return locked;
    }

    void setLeft(LockedTreeNode* l) {
        left = l;
    }

    void setRight(LockedTreeNode* r) {
        right = r;
    }

    bool canLockOrUnlock() {
        if (lockedDescendantCount > 0) return false;
        LockedTreeNode* current = parent;
        while (current) {
            if (current->locked) {
                return false;
            }

            current = current->parent;
        }
        return true;
    }

    bool lock() {
        if (locked) return false;
        if (!canLockOrUnlock()) return false;

        locked = true;
        LockedTreeNode* current = parent;
        while (current) {
            current->lockedDescendantCount++;
            current = current->parent;
        }

        return true;
    }

    bool unlock() {
        if (!locked) return false;
        if (!canLockOrUnlock()) return false;

        locked = false;
        LockedTreeNode* current = parent;
        while (current) {
            current->lockedDescendantCount--;
            current = current->parent;
        }

        return true;
    }
};

int main() {
    // Daily Coding Problem: Problem #24 [Medium] - 19/10/25
    // Main function generated by Claude
    // Build tree
    LockedTreeNode* A = new LockedTreeNode('A');
    LockedTreeNode* B = new LockedTreeNode('B', A);
    LockedTreeNode* C = new LockedTreeNode('C', A);
    LockedTreeNode* D = new LockedTreeNode('D', B);
    LockedTreeNode* E = new LockedTreeNode('E', B);

    A->setLeft(B);
    A->setRight(C);
    B->setLeft(D);
    B->setRight(E);

    cout << "Initial state: all unlocked\n";

    // Test 1: Lock D
    cout << "Lock D: " << D->lock() << " (expected 1)\n";
    assert(D->isLocked());

    // Test 2: Try to lock B (should fail because D is locked)
    cout << "Lock B (should fail): " << B->lock() << " (expected 0)\n";
    assert(!B->isLocked());

    // Test 3: Unlock D, then lock B
    cout << "Unlock D: " << D->unlock() << " (expected 1)\n";
    cout << "Lock B: " << B->lock() << " (expected 1)\n";
    assert(B->isLocked());

    // Test 4: Try to lock D again (should fail because B is locked)
    cout << "Lock D (should fail): " << D->lock() << " (expected 0)\n";
    assert(!D->isLocked());

    // Test 5: Try to lock A (should fail because B is locked)
    cout << "Lock A (should fail): " << A->lock() << " (expected 0)\n";
    assert(!A->isLocked());

    // Test 6: Unlock B, now lock A
    cout << "Unlock B: " << B->unlock() << " (expected 1)\n";
    cout << "Lock A: " << A->lock() << " (expected 1)\n";
    assert(A->isLocked());

    // Test 7: Try to lock C (should fail because ancestor A is locked)
    cout << "Lock C (should fail): " << C->lock() << " (expected 0)\n";
    assert(!C->isLocked());

    cout << "\nAll tests passed successfully!\n";
    return 0;
}
